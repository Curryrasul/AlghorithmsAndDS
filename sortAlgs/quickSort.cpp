// Быстрая сортировка (рекурсивный алгоритм)

// Алгоритм : делим массив на два [l ... q] и [q + 1 ... r], так, что все элементы  до arr[q] меньше
// него, а все элементы после arr[q] больше (возможно такое, что q это крайняя позиция в массиве).
// Затем рекурсивно вызываем алгоритм для двух частей
// Чтобы отсортировать массив с quickSort, нужно вызвать quickSort(arr, 0, len - 1)
// Сложность алгоритма - в среднем O(n * lg(n)). Возможен случай O(n^2), но вероятность мала.

int partition(int *arr, int l, int r) {
    // Берем средний элемент массива
    int v =  arr[(l + r)/2];
    // i - левый указатель, j - правый
    int i = l, j = r;
    // Пока указатели не пересеклись
    while (i < j) {
        // Пока значения элемента от левого указателя меньше v увеличиваем i
        // Иначе останавливаемся
        while (arr[i] < v) {
            i++;
        }
        // Пока значения элемента от правого указателя больше v уменьшаем j
        // Иначе останавливаемся
        while (arr[j] > v) {
            j--;
        }
        // Если пересеклись, то ничего не меняем
        if (i >= j) {
            break;
        }
        // Меняем элементы при указателях и после этого увеличиваем/уменьшаем значения указателей
        std::swap(arr[i++], arr[j--]);
    }
    return j;
}

void quickSort(int *arr, int l, int r) {
    // Пока left < rigth
    if (l < r) {
        // Ищем индекс разделителя
        int q = partition(arr, l, r);
        // Вызываем рекурисвно быструю сортировку для подмассивов
        quickSort(arr, l, q);
        quickSort(arr, q + 1, r);
    }
}