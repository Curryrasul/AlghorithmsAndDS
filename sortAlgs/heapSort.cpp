// Пирамидальная сортировка (Сортировка на основе кучи)

// Сортировка выполняется при помощи структуры данных двоичной кучи (binary heap). 
// Рекомендую почитать о данной структуре в других источниках, чтобы лучше понять. 
// Данная структура представляется в виде массива, где i-тый элемент это корень, а
// элементы с индексом 2*i + 1 и 2*i + 2 это его потомки. Высота пирамиды(кучи) соствляет порядок log(N)
// Суть пирамиды в том, что в корне всегда стоит максимальный (минимальный) элемент, добавление выполняется
// за log(N). 
// Алгоритм сортировки : строим кучу из нашего массива (сложность O(N)). Затем по свойствам макс. элемент
// будет находится в 0 позиции, меняем его с последним элементом. Далее упорядичиваем пирамиду
// но уже не включая в упорядочивание последний элемент и т.д, пока не останется 1 вершина.
// Сложность алгоритма O(N * log(N)). Алгоритм не устойчив. Для реализации требуются функции, нужные
// для поддержания двоичной кучи.

// Ставит элемент с индексом i в нужное место (туда, где он будет больше, чем потомки)
void heapify(int *arr, int i, int n) {
    // Начинаем закапывать элемент arr[i], пока он не встанет на свое место
    while (1) {
        // Левый и правый потомок элемента arr[i] соответственно 
        int l = 2 * i + 1;
        int r = 2 * i + 2;
        
        // Доп. переменная, чтобы понимать изменяли ли мы положение arr[i]
        int j = i;

        // Если индекс потомка меньше чем n и наш элемент меньше, чем потомок, то меняем индексы
        if (l < n && arr[i] < arr[l]) {
            i = l;
        }
        if (r < n && arr[i] < arr[r]) {
            i = r;
        }

        // Если равны, то ничего не поменялось и arr[i] на своем месте
        if (i == j) {
            break;
        }

        // Меняем элементы местами
        std::swap(arr[i], arr[j]);

    }
}

// Данный алгоритм строит из неупорядоченного массива бинарную кучу.
// Работает за O(N), т.к сложность heapify не постоянная. Читать доказательство ассимптотики в Кормен
void buildHeap(int *arr, int n) {
    // arr[n / 2 - 1] - это последний элемент у которого могут быть потомки 
    for (int i = (n / 2) - 1; i >= 0; i--) {
        // Вызываем heapify сверху вниз для каждого элемента, имеющего потомков.
        heapify(arr, i, n);
    }
}

// Сортировка
void heapSort(int *arr, int n) {
    // Делаем кучу из неупорядоченного массива (сразу же в начале будет лежать максимум)
    buildHeap(arr, n);

    // Уменьшаем границу
    for (int i = n - 1; i >= 0; i--) {
        // Кидаем максимальный элемент в конец
        std::swap(arr[0], arr[i]);
        // После обмена куча будет нарушена, поэтому нулевой элемент нужно вставить в нужную позицию
        heapify(arr, 0, i);
    }
}